"use strict";(self.webpackChunkdfmg_template=self.webpackChunkdfmg_template||[]).push([[7278],{31753:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return m}});var i=a(83117),n=(a(67294),a(3905)),r=a(1954);const o={title:"Class RecyclableMemoryStream",sidebar_label:"RecyclableMemoryStream",description:"MemoryStream implementation that deals with pooling and managing memory streams which use potentially large buffers.\n\nThis class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream objects to callers, while avoiding these specific problems: 1. LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC 2. Memory waste - A standard memory stream doubles its size when it runs out of room. This leads to continual memory growth as each stream approaches the maximum allowed size. 3. Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers. This implementation only copies the bytes when GetBuffer is called. 4. Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory can be easily reused.\nThe stream is implemented on top of a series of uniformly-sized blocks. As the stream&apos;s length grows, additional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream object itself.\nThe biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single  contiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks  are in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,  split by size--they are multiples/exponentials of a chunk size (1 MB by default).\nOnce a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the  large buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers  are maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."},l='<Icon icon="codicon:symbol-class" className="symbol-class" /> RecyclableMemoryStream',s={unversionedId:"api/ServiceStack.Text/RecyclableMemoryStream",id:"api/ServiceStack.Text/RecyclableMemoryStream",title:"Class RecyclableMemoryStream",description:"MemoryStream implementation that deals with pooling and managing memory streams which use potentially large buffers.\n\nThis class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream objects to callers, while avoiding these specific problems: 1. LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC 2. Memory waste - A standard memory stream doubles its size when it runs out of room. This leads to continual memory growth as each stream approaches the maximum allowed size. 3. Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers. This implementation only copies the bytes when GetBuffer is called. 4. Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory can be easily reused.\nThe stream is implemented on top of a series of uniformly-sized blocks. As the stream&apos;s length grows, additional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream object itself.\nThe biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single  contiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks  are in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,  split by size--they are multiples/exponentials of a chunk size (1 MB by default).\nOnce a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the  large buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers  are maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager).",source:"@site/docs/api/ServiceStack.Text/RecyclableMemoryStream.md",sourceDirName:"api/ServiceStack.Text",slug:"/api/ServiceStack.Text/RecyclableMemoryStream",permalink:"/api/ServiceStack.Text/RecyclableMemoryStream",draft:!1,tags:[],version:"current",frontMatter:{title:"Class RecyclableMemoryStream",sidebar_label:"RecyclableMemoryStream",description:"MemoryStream implementation that deals with pooling and managing memory streams which use potentially large buffers.\n\nThis class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream objects to callers, while avoiding these specific problems: 1. LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC 2. Memory waste - A standard memory stream doubles its size when it runs out of room. This leads to continual memory growth as each stream approaches the maximum allowed size. 3. Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers. This implementation only copies the bytes when GetBuffer is called. 4. Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory can be easily reused.\nThe stream is implemented on top of a series of uniformly-sized blocks. As the stream&apos;s length grows, additional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream object itself.\nThe biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single  contiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks  are in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,  split by size--they are multiples/exponentials of a chunk size (1 MB by default).\nOnce a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the  large buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers  are maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."},sidebar:"apiSidebar",previous:{title:"PropertyConvention",permalink:"/api/ServiceStack.Text/PropertyConvention"},next:{title:"RecyclableMemoryStreamManager.EventHandler",permalink:"/api/ServiceStack.Text/RecyclableMemoryStreamManager.EventHandler"}},c={},m=[{value:"<strong>Assembly</strong>: ServiceStack.Text.dll",id:"assembly-servicestacktextdll",level:6},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source",level:6},{value:"Properties",id:"properties",level:2},{value:'<Icon icon="codicon:symbol-property" className="symbol-property" /> Capacity',id:"-capacity",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-1",level:6},{value:'<Icon icon="codicon:symbol-property" className="symbol-property" /> Length',id:"-length",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-2",level:6},{value:'<Icon icon="codicon:symbol-property" className="symbol-property" /> Position',id:"-position",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-3",level:6},{value:'<Icon icon="codicon:symbol-property" className="symbol-property" /> CanRead',id:"-canread",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-4",level:6},{value:'<Icon icon="codicon:symbol-property" className="symbol-property" /> CanSeek',id:"-canseek",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-5",level:6},{value:'<Icon icon="codicon:symbol-property" className="symbol-property" /> CanTimeout',id:"-cantimeout",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-6",level:6},{value:'<Icon icon="codicon:symbol-property" className="symbol-property" /> CanWrite',id:"-canwrite",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-7",level:6},{value:"Methods",id:"methods",level:2},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> Finalize()',id:"-finalize",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-8",level:6},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> Dispose(Boolean)',id:"-disposeboolean",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-9",level:6},{value:"Parameters",id:"parameters",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> Close()',id:"-close",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-10",level:6},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> GetBuffer()',id:"-getbuffer",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-11",level:6},{value:"Returns",id:"returns",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> TryGetBuffer(out ArraySegment&lt;Byte&gt;)',id:"-trygetbufferout-arraysegmentbyte",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-12",level:6},{value:"Returns",id:"returns-1",level:5},{value:"Parameters",id:"parameters-1",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> ToArray()',id:"-toarray",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-13",level:6},{value:"Returns",id:"returns-2",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> Read(Byte[], Int32, Int32)',id:"-readbyte-int32-int32",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-14",level:6},{value:"Returns",id:"returns-3",level:5},{value:"Parameters",id:"parameters-2",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> SafeRead(Byte[], Int32, Int32, ref Int32)',id:"-safereadbyte-int32-int32-ref-int32",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-15",level:6},{value:"Returns",id:"returns-4",level:5},{value:"Parameters",id:"parameters-3",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> Write(Byte[], Int32, Int32)',id:"-writebyte-int32-int32",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-16",level:6},{value:"Parameters",id:"parameters-4",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> ToString()',id:"-tostring",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-17",level:6},{value:"Returns",id:"returns-5",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> WriteByte(Byte)',id:"-writebytebyte",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-18",level:6},{value:"Parameters",id:"parameters-5",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> ReadByte()',id:"-readbyte",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-19",level:6},{value:"Returns",id:"returns-6",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> SafeReadByte(ref Int32)',id:"-safereadbyteref-int32",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-20",level:6},{value:"Returns",id:"returns-7",level:5},{value:"Parameters",id:"parameters-6",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> SetLength(Int64)',id:"-setlengthint64",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-21",level:6},{value:"Parameters",id:"parameters-7",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> Seek(Int64, SeekOrigin)',id:"-seekint64-seekorigin",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-22",level:6},{value:"Returns",id:"returns-8",level:5},{value:"Parameters",id:"parameters-8",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> WriteTo(Stream)',id:"-writetostream",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-23",level:6},{value:"Parameters",id:"parameters-9",level:5},{value:'<Icon icon="codicon:symbol-method" className="symbol-method" /> WriteTo(Stream, Int32, Int32)',id:"-writetostream-int32-int32",level:3},{value:' <Icon icon="codicon:github-inverted" className="github-icon" /> View Source',id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-24",level:6},{value:"Parameters",id:"parameters-10",level:5},{value:"Implements",id:"implements",level:2}],u={toc:m};function d(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,i.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"-recyclablememorystream"},(0,n.kt)(r.JO,{icon:"codicon:symbol-class",className:"symbol-class",mdxType:"Icon"})," RecyclableMemoryStream"),(0,n.kt)("p",null,"MemoryStream implementation that deals with pooling and managing memory streams which use potentially large\nbuffers."),(0,n.kt)("p",null,"This class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream\nobjects to callers, while avoiding these specific problems:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC"),(0,n.kt)("li",{parentName:"ol"},"Memory waste - A standard memory stream doubles its size when it runs out of room. This\nleads to continual memory growth as each stream approaches the maximum allowed size."),(0,n.kt)("li",{parentName:"ol"},"Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.\nThis implementation only copies the bytes when GetBuffer is called."),(0,n.kt)("li",{parentName:"ol"},"Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory\ncan be easily reused.")),(0,n.kt)("p",null,"The stream is implemented on top of a series of uniformly-sized blocks. As the stream","'","s length grows,\nadditional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream\nobject itself."),(0,n.kt)("p",null,"The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single\ncontiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks\nare in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,\nsplit by size--they are multiples/exponentials of a chunk size (1 MB by default)."),(0,n.kt)("p",null,"Once a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the\nlarge buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers\nare maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."),(0,n.kt)("h6",{id:"assembly-servicestacktextdll"},(0,n.kt)("strong",{parentName:"h6"},"Assembly"),": ServiceStack.Text.dll"),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1175"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public sealed class RecyclableMemoryStream : MemoryStream, IDisposable\n")),(0,n.kt)("h2",{id:"properties"},"Properties"),(0,n.kt)("h3",{id:"-capacity"},(0,n.kt)(r.JO,{icon:"codicon:symbol-property",className:"symbol-property",mdxType:"Icon"})," Capacity"),(0,n.kt)("p",null,"Gets or sets the capacity"),(0,n.kt)("p",null,"This class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream\nobjects to callers, while avoiding these specific problems:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC"),(0,n.kt)("li",{parentName:"ol"},"Memory waste - A standard memory stream doubles its size when it runs out of room. This\nleads to continual memory growth as each stream approaches the maximum allowed size."),(0,n.kt)("li",{parentName:"ol"},"Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.\nThis implementation only copies the bytes when GetBuffer is called."),(0,n.kt)("li",{parentName:"ol"},"Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory\ncan be easily reused.")),(0,n.kt)("p",null,"The stream is implemented on top of a series of uniformly-sized blocks. As the stream","'","s length grows,\nadditional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream\nobject itself."),(0,n.kt)("p",null,"The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single\ncontiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks\nare in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,\nsplit by size--they are multiples/exponentials of a chunk size (1 MB by default)."),(0,n.kt)("p",null,"Once a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the\nlarge buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers\nare maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-1"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1458"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override int Capacity { get; set; }\n")),(0,n.kt)("h3",{id:"-length"},(0,n.kt)(r.JO,{icon:"codicon:symbol-property",className:"symbol-property",mdxType:"Icon"})," Length"),(0,n.kt)("p",null,"Gets the number of bytes written to this stream."),(0,n.kt)("p",null,"This class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream\nobjects to callers, while avoiding these specific problems:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC"),(0,n.kt)("li",{parentName:"ol"},"Memory waste - A standard memory stream doubles its size when it runs out of room. This\nleads to continual memory growth as each stream approaches the maximum allowed size."),(0,n.kt)("li",{parentName:"ol"},"Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.\nThis implementation only copies the bytes when GetBuffer is called."),(0,n.kt)("li",{parentName:"ol"},"Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory\ncan be easily reused.")),(0,n.kt)("p",null,"The stream is implemented on top of a series of uniformly-sized blocks. As the stream","'","s length grows,\nadditional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream\nobject itself."),(0,n.kt)("p",null,"The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single\ncontiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks\nare in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,\nsplit by size--they are multiples/exponentials of a chunk size (1 MB by default)."),(0,n.kt)("p",null,"Once a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the\nlarge buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers\nare maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-2"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1484"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override long Length { get; }\n")),(0,n.kt)("h3",{id:"-position"},(0,n.kt)(r.JO,{icon:"codicon:symbol-property",className:"symbol-property",mdxType:"Icon"})," Position"),(0,n.kt)("p",null,"Gets the current position in the stream"),(0,n.kt)("p",null,"This class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream\nobjects to callers, while avoiding these specific problems:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC"),(0,n.kt)("li",{parentName:"ol"},"Memory waste - A standard memory stream doubles its size when it runs out of room. This\nleads to continual memory growth as each stream approaches the maximum allowed size."),(0,n.kt)("li",{parentName:"ol"},"Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.\nThis implementation only copies the bytes when GetBuffer is called."),(0,n.kt)("li",{parentName:"ol"},"Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory\ncan be easily reused.")),(0,n.kt)("p",null,"The stream is implemented on top of a series of uniformly-sized blocks. As the stream","'","s length grows,\nadditional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream\nobject itself."),(0,n.kt)("p",null,"The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single\ncontiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks\nare in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,\nsplit by size--they are multiples/exponentials of a chunk size (1 MB by default)."),(0,n.kt)("p",null,"Once a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the\nlarge buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers\nare maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-3"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1499"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override long Position { get; set; }\n")),(0,n.kt)("h3",{id:"-canread"},(0,n.kt)(r.JO,{icon:"codicon:symbol-property",className:"symbol-property",mdxType:"Icon"})," CanRead"),(0,n.kt)("p",null,"Whether the stream can currently read"),(0,n.kt)("p",null,"This class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream\nobjects to callers, while avoiding these specific problems:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC"),(0,n.kt)("li",{parentName:"ol"},"Memory waste - A standard memory stream doubles its size when it runs out of room. This\nleads to continual memory growth as each stream approaches the maximum allowed size."),(0,n.kt)("li",{parentName:"ol"},"Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.\nThis implementation only copies the bytes when GetBuffer is called."),(0,n.kt)("li",{parentName:"ol"},"Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory\ncan be easily reused.")),(0,n.kt)("p",null,"The stream is implemented on top of a series of uniformly-sized blocks. As the stream","'","s length grows,\nadditional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream\nobject itself."),(0,n.kt)("p",null,"The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single\ncontiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks\nare in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,\nsplit by size--they are multiples/exponentials of a chunk size (1 MB by default)."),(0,n.kt)("p",null,"Once a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the\nlarge buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers\nare maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-4"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1526"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override bool CanRead { get; }\n")),(0,n.kt)("h3",{id:"-canseek"},(0,n.kt)(r.JO,{icon:"codicon:symbol-property",className:"symbol-property",mdxType:"Icon"})," CanSeek"),(0,n.kt)("p",null,"Whether the stream can currently seek"),(0,n.kt)("p",null,"This class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream\nobjects to callers, while avoiding these specific problems:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC"),(0,n.kt)("li",{parentName:"ol"},"Memory waste - A standard memory stream doubles its size when it runs out of room. This\nleads to continual memory growth as each stream approaches the maximum allowed size."),(0,n.kt)("li",{parentName:"ol"},"Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.\nThis implementation only copies the bytes when GetBuffer is called."),(0,n.kt)("li",{parentName:"ol"},"Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory\ncan be easily reused.")),(0,n.kt)("p",null,"The stream is implemented on top of a series of uniformly-sized blocks. As the stream","'","s length grows,\nadditional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream\nobject itself."),(0,n.kt)("p",null,"The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single\ncontiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks\nare in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,\nsplit by size--they are multiples/exponentials of a chunk size (1 MB by default)."),(0,n.kt)("p",null,"Once a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the\nlarge buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers\nare maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-5"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1531"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override bool CanSeek { get; }\n")),(0,n.kt)("h3",{id:"-cantimeout"},(0,n.kt)(r.JO,{icon:"codicon:symbol-property",className:"symbol-property",mdxType:"Icon"})," CanTimeout"),(0,n.kt)("p",null,"Always false"),(0,n.kt)("p",null,"This class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream\nobjects to callers, while avoiding these specific problems:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC"),(0,n.kt)("li",{parentName:"ol"},"Memory waste - A standard memory stream doubles its size when it runs out of room. This\nleads to continual memory growth as each stream approaches the maximum allowed size."),(0,n.kt)("li",{parentName:"ol"},"Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.\nThis implementation only copies the bytes when GetBuffer is called."),(0,n.kt)("li",{parentName:"ol"},"Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory\ncan be easily reused.")),(0,n.kt)("p",null,"The stream is implemented on top of a series of uniformly-sized blocks. As the stream","'","s length grows,\nadditional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream\nobject itself."),(0,n.kt)("p",null,"The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single\ncontiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks\nare in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,\nsplit by size--they are multiples/exponentials of a chunk size (1 MB by default)."),(0,n.kt)("p",null,"Once a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the\nlarge buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers\nare maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-6"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1536"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override bool CanTimeout { get; }\n")),(0,n.kt)("h3",{id:"-canwrite"},(0,n.kt)(r.JO,{icon:"codicon:symbol-property",className:"symbol-property",mdxType:"Icon"})," CanWrite"),(0,n.kt)("p",null,"Whether the stream can currently write"),(0,n.kt)("p",null,"This class works in tandem with the RecyclableMemoryStreamManager to supply MemoryStream\nobjects to callers, while avoiding these specific problems:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC"),(0,n.kt)("li",{parentName:"ol"},"Memory waste - A standard memory stream doubles its size when it runs out of room. This\nleads to continual memory growth as each stream approaches the maximum allowed size."),(0,n.kt)("li",{parentName:"ol"},"Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.\nThis implementation only copies the bytes when GetBuffer is called."),(0,n.kt)("li",{parentName:"ol"},"Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory\ncan be easily reused.")),(0,n.kt)("p",null,"The stream is implemented on top of a series of uniformly-sized blocks. As the stream","'","s length grows,\nadditional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream\nobject itself."),(0,n.kt)("p",null,"The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single\ncontiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks\nare in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled,\nsplit by size--they are multiples/exponentials of a chunk size (1 MB by default)."),(0,n.kt)("p",null,"Once a large buffer is assigned to the stream the small blocks are NEVER again used for this stream. All operations take place on the\nlarge buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers\nare maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager)."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-7"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1541"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override bool CanWrite { get; }\n")),(0,n.kt)("h2",{id:"methods"},"Methods"),(0,n.kt)("h3",{id:"-finalize"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," Finalize()"),(0,n.kt)("p",null,"The finalizer will be called when a stream is not disposed properly. "),(0,n.kt)("p",null,"Failing to dispose indicates a bug in the code using streams. Care should be taken to properly account for stream lifetime."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-8"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1358"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"protected void Finalize()\n")),(0,n.kt)("h3",{id:"-disposeboolean"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," Dispose(Boolean)"),(0,n.kt)("p",null,"Returns the memory used by this stream back to the pool."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-9"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1367"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"protected override void Dispose(bool disposing)\n")),(0,n.kt)("h5",{id:"parameters"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.Boolean")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"disposing")),(0,n.kt)("td",{parentName:"tr",align:"left"},"Whether we","'","re disposing (true), or being called by the finalizer (false)")))),(0,n.kt)("p",null," |"),(0,n.kt)("h3",{id:"-close"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," Close()"),(0,n.kt)("p",null,"Equivalent to Dispose"),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-10"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1439"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override void Close()\n")),(0,n.kt)("h3",{id:"-getbuffer"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," GetBuffer()"),(0,n.kt)("p",null,"Returns a single buffer containing the contents of the stream.\nThe buffer may be longer than the stream length."),(0,n.kt)("p",null,"IMPORTANT: Doing a Write() after calling GetBuffer() invalidates the buffer. The old buffer is held onto\nuntil Dispose is called, but the next time GetBuffer() is called, a new buffer from the pool will be required."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-11"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1554"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override byte[] GetBuffer()\n")),(0,n.kt)("h5",{id:"returns"},"Returns"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"System.Byte[]"),": A byte[] buffer\nIMPORTANT: Doing a Write() after calling GetBuffer() invalidates the buffer. The old buffer is held onto\nuntil Dispose is called, but the next time GetBuffer() is called, a new buffer from the pool will be required."),(0,n.kt)("h3",{id:"-trygetbufferout-arraysegmentbyte"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," TryGetBuffer(out ArraySegment","<","Byte",">",")"),(0,n.kt)("p",null,"Returns an ArraySegment that wraps a single buffer containing the contents of the stream."),(0,n.kt)("p",null,"GetBuffer has no failure modes (it always returns something, even if it","'","s an empty buffer), therefore this method\nalways returns a valid ArraySegment to the same buffer returned by GetBuffer."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-12"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1596"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override bool TryGetBuffer(out ArraySegment<byte> buffer)\n")),(0,n.kt)("h5",{id:"returns-1"},"Returns"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"System.Boolean"),": Always returns true.\nGetBuffer has no failure modes (it always returns something, even if it","'","s an empty buffer), therefore this method\nalways returns a valid ArraySegment to the same buffer returned by GetBuffer."),(0,n.kt)("h5",{id:"parameters-1"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.ArraySegment<System.Byte>")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"buffer")),(0,n.kt)("td",{parentName:"tr",align:"left"},"An ArraySegment containing a reference to the underlying bytes.")))),(0,n.kt)("p",null,"GetBuffer has no failure modes (it always returns something, even if it","'","s an empty buffer), therefore this method\nalways returns a valid ArraySegment to the same buffer returned by GetBuffer.\n|"),(0,n.kt)("h3",{id:"-toarray"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," ToArray()"),(0,n.kt)("p",null,"Returns a new array with a copy of the buffer","'","s contents. You should almost certainly be using GetBuffer combined with the Length to\naccess the bytes in this stream. Calling ToArray will destroy the benefits of pooled buffers, but it is included\nfor the sake of completeness."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-13"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1612"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},'[Obsolete("This method has degraded performance vs. GetBuffer and should be avoided.")]\npublic override byte[] ToArray()\n')),(0,n.kt)("h5",{id:"returns-2"},"Returns"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"System.Byte[]")),(0,n.kt)("h3",{id:"-readbyte-int32-int32"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," Read(Byte[], Int32, Int32)"),(0,n.kt)("p",null,"Reads from the current position into the provided buffer"),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-14"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1645"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override int Read(byte[] buffer, int offset, int count)\n")),(0,n.kt)("h5",{id:"returns-3"},"Returns"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32"),": The number of bytes read"),(0,n.kt)("h5",{id:"parameters-2"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.Byte[]")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"buffer")),(0,n.kt)("td",{parentName:"tr",align:"left"},"Destination buffer")))),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32")," | ",(0,n.kt)("em",{parentName:"p"},"offset")," | Offset into buffer at which to start placing the read bytes."),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32")," | ",(0,n.kt)("em",{parentName:"p"},"count")," | Number of bytes to read."),(0,n.kt)("p",null," |"),(0,n.kt)("h3",{id:"-safereadbyte-int32-int32-ref-int32"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," SafeRead(Byte[], Int32, Int32, ref Int32)"),(0,n.kt)("p",null,"Reads from the specified position into the provided buffer"),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-15"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1662"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public int SafeRead(byte[] buffer, int offset, int count, ref int streamPosition)\n")),(0,n.kt)("h5",{id:"returns-4"},"Returns"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32"),": The number of bytes read"),(0,n.kt)("h5",{id:"parameters-3"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.Byte[]")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"buffer")),(0,n.kt)("td",{parentName:"tr",align:"left"},"Destination buffer")))),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32")," | ",(0,n.kt)("em",{parentName:"p"},"offset")," | Offset into buffer at which to start placing the read bytes."),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32")," | ",(0,n.kt)("em",{parentName:"p"},"count")," | Number of bytes to read."),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32")," | ",(0,n.kt)("em",{parentName:"p"},"streamPosition")," | Position in the stream to start reading from"),(0,n.kt)("p",null," |"),(0,n.kt)("h3",{id:"-writebyte-int32-int32"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," Write(Byte[], Int32, Int32)"),(0,n.kt)("p",null,"Writes the buffer to the stream"),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-16"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1729"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override void Write(byte[] buffer, int offset, int count)\n")),(0,n.kt)("h5",{id:"parameters-4"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.Byte[]")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"buffer")),(0,n.kt)("td",{parentName:"tr",align:"left"},"Source buffer")))),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32")," | ",(0,n.kt)("em",{parentName:"p"},"offset")," | Start position"),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32")," | ",(0,n.kt)("em",{parentName:"p"},"count")," | Number of bytes to write"),(0,n.kt)("p",null," |"),(0,n.kt)("h3",{id:"-tostring"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," ToString()"),(0,n.kt)("p",null,"Returns a useful string for debugging. This should not normally be called in actual production code."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-17"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1845"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override string ToString()\n")),(0,n.kt)("h5",{id:"returns-5"},"Returns"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"System.String")),(0,n.kt)("h3",{id:"-writebytebyte"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," WriteByte(Byte)"),(0,n.kt)("p",null,"Writes a single byte to the current position in the stream."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-18"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1855"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override void WriteByte(byte value)\n")),(0,n.kt)("h5",{id:"parameters-5"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.Byte")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"value")),(0,n.kt)("td",{parentName:"tr",align:"left"},"byte value to write")))),(0,n.kt)("p",null," |"),(0,n.kt)("h3",{id:"-readbyte"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," ReadByte()"),(0,n.kt)("p",null,"Reads a single byte from the current position in the stream."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-19"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1903"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override int ReadByte()\n")),(0,n.kt)("h5",{id:"returns-6"},"Returns"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32"),": The byte at the current position, or -1 if the position is at the end of the stream."),(0,n.kt)("h3",{id:"-safereadbyteref-int32"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," SafeReadByte(ref Int32)"),(0,n.kt)("p",null,"Reads a single byte from the specified position in the stream."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-20"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1914"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public int SafeReadByte(ref int streamPosition)\n")),(0,n.kt)("h5",{id:"returns-7"},"Returns"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32"),": The byte at the current position, or -1 if the position is at the end of the stream."),(0,n.kt)("h5",{id:"parameters-6"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.Int32")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"streamPosition")),(0,n.kt)("td",{parentName:"tr",align:"left"},"The position in the stream to read from")))),(0,n.kt)("p",null," |"),(0,n.kt)("h3",{id:"-setlengthint64"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," SetLength(Int64)"),(0,n.kt)("p",null,"Sets the length of the stream"),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-21"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1940"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override void SetLength(long value)\n")),(0,n.kt)("h5",{id:"parameters-7"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.Int64")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"value"))))),(0,n.kt)("h3",{id:"-seekint64-seekorigin"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," Seek(Int64, SeekOrigin)"),(0,n.kt)("p",null,"Sets the position to the offset from the seek location"),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-22"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L1968"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override long Seek(long offset, SeekOrigin loc)\n")),(0,n.kt)("h5",{id:"returns-8"},"Returns"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"System.Int64"),": The new position"),(0,n.kt)("h5",{id:"parameters-8"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.Int64")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"offset")),(0,n.kt)("td",{parentName:"tr",align:"left"},"How many bytes to move")))),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.IO.SeekOrigin")," | ",(0,n.kt)("em",{parentName:"p"},"loc")," | From where"),(0,n.kt)("p",null," |"),(0,n.kt)("h3",{id:"-writetostream"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," WriteTo(Stream)"),(0,n.kt)("p",null,"Synchronously writes this stream","'","s bytes to the argument stream."),(0,n.kt)("p",null,"Important: This does a synchronous write, which may not be desired in some situations"),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-23"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L2005"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public override void WriteTo(Stream stream)\n")),(0,n.kt)("h5",{id:"parameters-9"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.IO.Stream")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"stream")),(0,n.kt)("td",{parentName:"tr",align:"left"},"Destination stream")))),(0,n.kt)("p",null,"Important: This does a synchronous write, which may not be desired in some situations\n|"),(0,n.kt)("h3",{id:"-writetostream-int32-int32"},(0,n.kt)(r.JO,{icon:"codicon:symbol-method",className:"symbol-method",mdxType:"Icon"})," WriteTo(Stream, Int32, Int32)"),(0,n.kt)("p",null,"Synchronously writes this stream","'","s bytes, starting at offset, for count bytes, to the argument stream."),(0,n.kt)("h6",{id:"-icon-iconcodicongithub-inverted-classnamegithub-icon--view-source-24"},(0,n.kt)("a",{parentName:"h6",href:"https://github.com/ServiceStack/ServiceStack/blob/main/ServiceStack.Text/src/ServiceStack.Text/RecyclableMemoryStream.cs#L2018"}," ",(0,n.kt)(r.JO,{icon:"codicon:github-inverted",className:"github-icon",mdxType:"Icon"})," View Source")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Declaration"',title:'"Declaration"'},"public void WriteTo(Stream stream, int offset, int count)\n")),(0,n.kt)("h5",{id:"parameters-10"},"Parameters"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,n.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("inlineCode",{parentName:"td"},"System.IO.Stream")),(0,n.kt)("td",{parentName:"tr",align:"left"},(0,n.kt)("em",{parentName:"td"},"stream")),(0,n.kt)("td",{parentName:"tr",align:"left"},"Destination stream")))),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32")," | ",(0,n.kt)("em",{parentName:"p"},"offset")," | Offset in source"),(0,n.kt)("p",null," |\n| ",(0,n.kt)("inlineCode",{parentName:"p"},"System.Int32")," | ",(0,n.kt)("em",{parentName:"p"},"count")," | Number of bytes to write"),(0,n.kt)("p",null," |"),(0,n.kt)("h2",{id:"implements"},"Implements"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"System.IDisposable"))))}d.isMDXComponent=!0}}]);